{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Confidential ML Utilities Confidential ML is the practice of training machine learning models without seeing the training data. It is needed in many enterprises to satisfy the strict compliance and privacy guarantees they provide to their customers. This repository contains a set of utilities for confidential ML, with a special emphasis on using PyTorch in Azure Machine Learning pipelines . Using Compliant logging library see: docs/logging Minimal use case: from confidential_ml_utils import DataCategory, enable_confidential_logging, prefix_stack_trace import logging @prefix_stack_trace(allow_list=[\"FileNotFoundError\", \"TypeError\"]) def main(): enable_confidential_logging() log = logging.getLogger(__name__) log.info(\"Hi there\", category=DataCategory.PUBLIC) if __name__ == \"__main__\": main() VS Code Snippets see: docs/snippets Contributing This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com. When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Home"},{"location":"#confidential-ml-utilities","text":"Confidential ML is the practice of training machine learning models without seeing the training data. It is needed in many enterprises to satisfy the strict compliance and privacy guarantees they provide to their customers. This repository contains a set of utilities for confidential ML, with a special emphasis on using PyTorch in Azure Machine Learning pipelines .","title":"Confidential ML Utilities"},{"location":"#using","text":"Compliant logging library see: docs/logging Minimal use case: from confidential_ml_utils import DataCategory, enable_confidential_logging, prefix_stack_trace import logging @prefix_stack_trace(allow_list=[\"FileNotFoundError\", \"TypeError\"]) def main(): enable_confidential_logging() log = logging.getLogger(__name__) log.info(\"Hi there\", category=DataCategory.PUBLIC) if __name__ == \"__main__\": main() VS Code Snippets see: docs/snippets","title":"Using"},{"location":"#contributing","text":"This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com. When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Contributing"},{"location":"constants/","text":"Constants Constant values used by this library. DataCategory Enumeration of data categories in confidential machine learning. Values: - PRIVATE: data which is private. Researchers may not view this. - PUBLIC: data which may safely be viewed by researchers.","title":"constants"},{"location":"constants/#constants","text":"","title":"Constants"},{"location":"constants/#confidential_ml_utils.constants","text":"Constant values used by this library.","title":"confidential_ml_utils.constants"},{"location":"constants/#confidential_ml_utils.constants.DataCategory","text":"Enumeration of data categories in confidential machine learning. Values: - PRIVATE: data which is private. Researchers may not view this. - PUBLIC: data which may safely be viewed by researchers.","title":"DataCategory"},{"location":"exceptions/","text":"Exceptions Decorators and utilities for prefixing exception stack traces while obscuring the exception message itself. PublicArgumentError Argument error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception. PublicKeyError Key error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception. PublicRuntimeError Runtime error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception. PublicTypeError Type error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception. PublicValueError Value error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception. is_exception_allowed ( exception , allow_list ) Check if message is allowed, either by allow_list , or default_allow_list . Parameters: Name Type Description Default exception Union[BaseException, traceback.TracebackException] the exception to test required allow_list list list of regex expressions. If any expression matches the exception name or message, it will be considered allowed. required Returns: Type Description bool bool: True if message is allowed, False otherwise. Source code in confidential_ml_utils\\exceptions.py def is_exception_allowed ( exception : Union [ BaseException , TracebackException ], allow_list : list ) -> bool : \"\"\" Check if message is allowed, either by `allow_list`, or `default_allow_list`. Args: exception (TracebackException): the exception to test allow_list (list): list of regex expressions. If any expression matches the exception name or message, it will be considered allowed. Returns: bool: True if message is allowed, False otherwise. \"\"\" if not isinstance ( exception , TracebackException ): exception = TracebackException . from_exception ( exception ) # empty list means all messages are allowed for expr in allow_list + default_allow_list : if re . search ( expr , getattr ( exception , \"_str\" , \"\" ), re . IGNORECASE ): return True if re . search ( expr , getattr ( exception . exc_type , \"__name__\" , \"\" ), re . IGNORECASE ): return True return False prefix_stack_trace ( file =< _io . TextIOWrapper name = '<stderr>' mode = 'w' encoding = 'cp1252' > , disable = False , prefix = 'SystemLog:' , scrub_message = '**Exception message scrubbed**' , keep_message = False , allow_list = [], add_timestamp = False ) Decorator which wraps the decorated function and prints the stack trace of exceptions which occur, prefixed with prefix and with exception messages scrubbed (replaced with scrub_message ). To use this, just add @prefix_stack_trace() above your function definition, e.g. @prefix_stack_trace() def foo(x): pass Source code in confidential_ml_utils\\exceptions.py def prefix_stack_trace ( file : TextIO = sys . stderr , disable : bool = bool ( sys . flags . debug ), prefix : str = PREFIX , scrub_message : str = SCRUB_MESSAGE , keep_message : bool = False , allow_list : list = [], add_timestamp : bool = False , ) -> Callable : \"\"\" Decorator which wraps the decorated function and prints the stack trace of exceptions which occur, prefixed with `prefix` and with exception messages scrubbed (replaced with `scrub_message`). To use this, just add `@prefix_stack_trace()` above your function definition, e.g. @prefix_stack_trace() def foo(x): pass \"\"\" return _PrefixStackTraceWrapper ( file , disable , prefix , scrub_message , keep_message , allow_list , add_timestamp ) print_prefixed_stack_trace_and_raise ( file =< _io . TextIOWrapper name = '<stderr>' mode = 'w' encoding = 'cp1252' > , prefix = 'SystemLog:' , scrub_message = '**Exception message scrubbed**' , keep_message = False , allow_list = [], add_timestamp = False , err = None ) Print the current exception and stack trace to file (usually client standard error), prefixing the stack trace with prefix . Parameters: Name Type Description Default keep_message bool if True, don't scrub message. If false, scrub (unless allowed). False allow_list list exception allow_list. Ignored if keep_message is True. If empty all messages will be srubbed. [] err Optional[BaseException] the error that was thrown. None accepted for backwards compatibility. None Source code in confidential_ml_utils\\exceptions.py def print_prefixed_stack_trace_and_raise ( file : TextIO = sys . stderr , prefix : str = PREFIX , scrub_message : str = SCRUB_MESSAGE , keep_message : bool = False , allow_list : list = [], add_timestamp : bool = False , err : Optional [ BaseException ] = None , ) -> None : \"\"\" Print the current exception and stack trace to `file` (usually client standard error), prefixing the stack trace with `prefix`. Args: keep_message (bool): if True, don't scrub message. If false, scrub (unless allowed). allow_list (list): exception allow_list. Ignored if keep_message is True. If empty all messages will be srubbed. err: the error that was thrown. None accepted for backwards compatibility. \"\"\" if err is None : err = sys . exc_info ()[ 1 ] scrubbed_err = scrub_exception ( err , scrub_message , prefix , keep_message , allow_list ) tb_exception = TracebackException . from_exception ( scrubbed_err ) # type: ignore for execution in tb_exception . format (): if \"return function(*func_args, **func_kwargs)\" in execution : # Do not show the stack trace for our decorator. continue for line in execution . splitlines (): if add_timestamp : current_time = time . strftime ( \"%Y-%m- %d %H:%M:%S\" , time . localtime ()) print ( f \" { prefix } { current_time } { line } \" , file = file ) else : print ( f \" { prefix } { line } \" , file = file ) raise scrubbed_err # type: ignore scrub_exception ( exception , scrub_message , prefix , keep_message , allow_list , _seen = None ) Recursively scrub all potentially private data from an exception, using the logic in _attribute_transformer . Inspired by Dan Schwartz's closed-source implementation: https://dev.azure.com/eemo/TEE/_git/TEEGit?path=%2FOffline%2FFocusedInbox%2FComTriage%2Fcomtriage%2Futils%2Fscrubber.py&version=GBcompliant%2FComTriage&_a=content which is closely based on the CPython implementation of the TracebackException class: https://github.com/python/cpython/blob/master/Lib/traceback.py#L478 Source code in confidential_ml_utils\\exceptions.py def scrub_exception ( exception : Optional [ BaseException ], scrub_message : str , prefix : str , keep_message : bool , allow_list : list , _seen : Optional [ Set [ int ]] = None , ) -> Optional [ BaseException ]: \"\"\" Recursively scrub all potentially private data from an exception, using the logic in `_attribute_transformer`. Inspired by Dan Schwartz's closed-source implementation: https://dev.azure.com/eemo/TEE/_git/TEEGit?path=%2FOffline%2FFocusedInbox%2FComTriage%2Fcomtriage%2Futils%2Fscrubber.py&version=GBcompliant%2FComTriage&_a=content which is closely based on the CPython implementation of the TracebackException class: https://github.com/python/cpython/blob/master/Lib/traceback.py#L478 \"\"\" if not exception : return None # Handle loops in __cause__ or __context__ . if _seen is None : _seen = set () _seen . add ( id ( exception )) # Gracefully handle being called with no type or value. if exception . __cause__ is not None and id ( exception . __cause__ ) not in _seen : exception . __cause__ = scrub_exception ( exception . __cause__ , scrub_message , prefix , keep_message , allow_list , _seen , ) if exception . __context__ is not None and id ( exception . __context__ ) not in _seen : exception . __context__ = scrub_exception ( exception . __context__ , scrub_message , prefix , keep_message , allow_list , _seen , ) keep = keep_message or is_exception_allowed ( exception , allow_list ) transformer = _attribute_transformer ( prefix , scrub_message , keep ) for attr in dir ( exception ): if attr and not attr . startswith ( \"__\" ): value = getattr ( exception , attr ) new_value = transformer ( value ) setattr ( exception , attr , new_value ) return exception","title":"exceptions"},{"location":"exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"exceptions/#confidential_ml_utils.exceptions","text":"Decorators and utilities for prefixing exception stack traces while obscuring the exception message itself.","title":"confidential_ml_utils.exceptions"},{"location":"exceptions/#confidential_ml_utils.exceptions.PublicArgumentError","text":"Argument error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception.","title":"PublicArgumentError"},{"location":"exceptions/#confidential_ml_utils.exceptions.PublicKeyError","text":"Key error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception.","title":"PublicKeyError"},{"location":"exceptions/#confidential_ml_utils.exceptions.PublicRuntimeError","text":"Runtime error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception.","title":"PublicRuntimeError"},{"location":"exceptions/#confidential_ml_utils.exceptions.PublicTypeError","text":"Type error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception.","title":"PublicTypeError"},{"location":"exceptions/#confidential_ml_utils.exceptions.PublicValueError","text":"Value error with public message. Exceptions of this type raised under prefix_stack_trace or print_prefixed_stack_trace_and_raise will have the message prefixed with PREFIX in both the printed stack trace and the re-raised exception.","title":"PublicValueError"},{"location":"exceptions/#confidential_ml_utils.exceptions.is_exception_allowed","text":"Check if message is allowed, either by allow_list , or default_allow_list . Parameters: Name Type Description Default exception Union[BaseException, traceback.TracebackException] the exception to test required allow_list list list of regex expressions. If any expression matches the exception name or message, it will be considered allowed. required Returns: Type Description bool bool: True if message is allowed, False otherwise. Source code in confidential_ml_utils\\exceptions.py def is_exception_allowed ( exception : Union [ BaseException , TracebackException ], allow_list : list ) -> bool : \"\"\" Check if message is allowed, either by `allow_list`, or `default_allow_list`. Args: exception (TracebackException): the exception to test allow_list (list): list of regex expressions. If any expression matches the exception name or message, it will be considered allowed. Returns: bool: True if message is allowed, False otherwise. \"\"\" if not isinstance ( exception , TracebackException ): exception = TracebackException . from_exception ( exception ) # empty list means all messages are allowed for expr in allow_list + default_allow_list : if re . search ( expr , getattr ( exception , \"_str\" , \"\" ), re . IGNORECASE ): return True if re . search ( expr , getattr ( exception . exc_type , \"__name__\" , \"\" ), re . IGNORECASE ): return True return False","title":"is_exception_allowed()"},{"location":"exceptions/#confidential_ml_utils.exceptions.prefix_stack_trace","text":"Decorator which wraps the decorated function and prints the stack trace of exceptions which occur, prefixed with prefix and with exception messages scrubbed (replaced with scrub_message ). To use this, just add @prefix_stack_trace() above your function definition, e.g. @prefix_stack_trace() def foo(x): pass Source code in confidential_ml_utils\\exceptions.py def prefix_stack_trace ( file : TextIO = sys . stderr , disable : bool = bool ( sys . flags . debug ), prefix : str = PREFIX , scrub_message : str = SCRUB_MESSAGE , keep_message : bool = False , allow_list : list = [], add_timestamp : bool = False , ) -> Callable : \"\"\" Decorator which wraps the decorated function and prints the stack trace of exceptions which occur, prefixed with `prefix` and with exception messages scrubbed (replaced with `scrub_message`). To use this, just add `@prefix_stack_trace()` above your function definition, e.g. @prefix_stack_trace() def foo(x): pass \"\"\" return _PrefixStackTraceWrapper ( file , disable , prefix , scrub_message , keep_message , allow_list , add_timestamp )","title":"prefix_stack_trace()"},{"location":"exceptions/#confidential_ml_utils.exceptions.print_prefixed_stack_trace_and_raise","text":"Print the current exception and stack trace to file (usually client standard error), prefixing the stack trace with prefix . Parameters: Name Type Description Default keep_message bool if True, don't scrub message. If false, scrub (unless allowed). False allow_list list exception allow_list. Ignored if keep_message is True. If empty all messages will be srubbed. [] err Optional[BaseException] the error that was thrown. None accepted for backwards compatibility. None Source code in confidential_ml_utils\\exceptions.py def print_prefixed_stack_trace_and_raise ( file : TextIO = sys . stderr , prefix : str = PREFIX , scrub_message : str = SCRUB_MESSAGE , keep_message : bool = False , allow_list : list = [], add_timestamp : bool = False , err : Optional [ BaseException ] = None , ) -> None : \"\"\" Print the current exception and stack trace to `file` (usually client standard error), prefixing the stack trace with `prefix`. Args: keep_message (bool): if True, don't scrub message. If false, scrub (unless allowed). allow_list (list): exception allow_list. Ignored if keep_message is True. If empty all messages will be srubbed. err: the error that was thrown. None accepted for backwards compatibility. \"\"\" if err is None : err = sys . exc_info ()[ 1 ] scrubbed_err = scrub_exception ( err , scrub_message , prefix , keep_message , allow_list ) tb_exception = TracebackException . from_exception ( scrubbed_err ) # type: ignore for execution in tb_exception . format (): if \"return function(*func_args, **func_kwargs)\" in execution : # Do not show the stack trace for our decorator. continue for line in execution . splitlines (): if add_timestamp : current_time = time . strftime ( \"%Y-%m- %d %H:%M:%S\" , time . localtime ()) print ( f \" { prefix } { current_time } { line } \" , file = file ) else : print ( f \" { prefix } { line } \" , file = file ) raise scrubbed_err # type: ignore","title":"print_prefixed_stack_trace_and_raise()"},{"location":"exceptions/#confidential_ml_utils.exceptions.scrub_exception","text":"Recursively scrub all potentially private data from an exception, using the logic in _attribute_transformer . Inspired by Dan Schwartz's closed-source implementation: https://dev.azure.com/eemo/TEE/_git/TEEGit?path=%2FOffline%2FFocusedInbox%2FComTriage%2Fcomtriage%2Futils%2Fscrubber.py&version=GBcompliant%2FComTriage&_a=content which is closely based on the CPython implementation of the TracebackException class: https://github.com/python/cpython/blob/master/Lib/traceback.py#L478 Source code in confidential_ml_utils\\exceptions.py def scrub_exception ( exception : Optional [ BaseException ], scrub_message : str , prefix : str , keep_message : bool , allow_list : list , _seen : Optional [ Set [ int ]] = None , ) -> Optional [ BaseException ]: \"\"\" Recursively scrub all potentially private data from an exception, using the logic in `_attribute_transformer`. Inspired by Dan Schwartz's closed-source implementation: https://dev.azure.com/eemo/TEE/_git/TEEGit?path=%2FOffline%2FFocusedInbox%2FComTriage%2Fcomtriage%2Futils%2Fscrubber.py&version=GBcompliant%2FComTriage&_a=content which is closely based on the CPython implementation of the TracebackException class: https://github.com/python/cpython/blob/master/Lib/traceback.py#L478 \"\"\" if not exception : return None # Handle loops in __cause__ or __context__ . if _seen is None : _seen = set () _seen . add ( id ( exception )) # Gracefully handle being called with no type or value. if exception . __cause__ is not None and id ( exception . __cause__ ) not in _seen : exception . __cause__ = scrub_exception ( exception . __cause__ , scrub_message , prefix , keep_message , allow_list , _seen , ) if exception . __context__ is not None and id ( exception . __context__ ) not in _seen : exception . __context__ = scrub_exception ( exception . __context__ , scrub_message , prefix , keep_message , allow_list , _seen , ) keep = keep_message or is_exception_allowed ( exception , allow_list ) transformer = _attribute_transformer ( prefix , scrub_message , keep ) for attr in dir ( exception ): if attr and not attr . startswith ( \"__\" ): value = getattr ( exception , attr ) new_value = transformer ( value ) setattr ( exception , attr , new_value ) return exception","title":"scrub_exception()"},{"location":"logging/","text":"Logging Utilities around logging data which may or may not contain private content. ConfidentialLogger Subclass of the default logging class with an explicit category parameter on all logging methods. It will pass an extra param with prefix key (value depending on whether category is public or private) to the handlers. The default value for data category is PRIVATE for all methods. Implementation is inspired by: https://github.com/python/cpython/blob/3.8/Lib/logging/ init .py critical ( self , msg , category =< DataCategory . PRIVATE : 1 > , * args , ** kwargs ) Log msg % args with severity CRITICAL . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.critical(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def critical ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `CRITICAL`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.critical(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( CRITICAL ): self . _log ( CRITICAL , msg , category , args , ** kwargs ) debug ( self , msg , category =< DataCategory . PRIVATE : 1 > , * args , ** kwargs ) Log msg % args with severity DEBUG . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.debug(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def debug ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `DEBUG`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.debug(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( DEBUG ): self . _log ( DEBUG , msg , category , args , ** kwargs ) error ( self , msg , category =< DataCategory . PRIVATE : 1 > , * args , ** kwargs ) Log msg % args with severity ERROR . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.error(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def error ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `ERROR`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.error(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( ERROR ): self . _log ( ERROR , msg , category , args , ** kwargs ) info ( self , msg , category =< DataCategory . PRIVATE : 1 > , * args , ** kwargs ) Log msg % args with severity INFO . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.info(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def info ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `INFO`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.info(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( INFO ): self . _log ( INFO , msg , category , args , ** kwargs ) warning ( self , msg , category =< DataCategory . PRIVATE : 1 > , * args , ** kwargs ) Log msg % args with severity WARNING . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.warning(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def warning ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `WARNING`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.warning(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( WARNING ): self . _log ( WARNING , msg , category , args , ** kwargs ) enable_confidential_logging ( prefix = 'SystemLog:' , ** kwargs ) The default format is logging.BASIC_FORMAT ( %(levelname)s:%(name)s:%(message)s ). All other kwargs are passed to logging.basicConfig . Sets the default logger class and root logger to be confidential. This means the format string %(prefix) will work. Set the format using the format kwarg. If running in Python >= 3.8, will attempt to add force=True to the kwargs for logging.basicConfig. After calling this method, use the kwarg category to pass in a value of DataCategory to denote data category. The default is PRIVATE . That is, if no changes are made to an existing set of log statements, the log output should be the same. The standard implementation of the logging API is a good reference: https://github.com/python/cpython/blob/3.9/Lib/logging/ init .py Source code in confidential_ml_utils\\logging.py def enable_confidential_logging ( prefix : str = \"SystemLog:\" , ** kwargs ) -> None : \"\"\" The default format is `logging.BASIC_FORMAT` (`%(levelname)s:%(name)s:%(message)s`). All other kwargs are passed to `logging.basicConfig`. Sets the default logger class and root logger to be confidential. This means the format string `%(prefix)` will work. Set the format using the `format` kwarg. If running in Python >= 3.8, will attempt to add `force=True` to the kwargs for logging.basicConfig. After calling this method, use the kwarg `category` to pass in a value of `DataCategory` to denote data category. The default is `PRIVATE`. That is, if no changes are made to an existing set of log statements, the log output should be the same. The standard implementation of the logging API is a good reference: https://github.com/python/cpython/blob/3.9/Lib/logging/__init__.py \"\"\" set_prefix ( prefix ) if \"format\" not in kwargs : kwargs [ \"format\" ] = f \"%(prefix)s { logging . BASIC_FORMAT } \" # Ensure that all loggers created via `logging.getLogger` are instances of # the `ConfidentialLogger` class. logging . setLoggerClass ( ConfidentialLogger ) if len ( logging . root . handlers ) > 0 : p = get_prefix () for line in _logging_basic_config_set_warning . splitlines (): print ( f \" { p }{ line } \" , file = sys . stderr ) if \"force\" not in kwargs and sys . version_info >= ( 3 , 8 ): kwargs [ \"force\" ] = True old_root = logging . root root = ConfidentialLogger ( logging . root . name ) root . handlers = old_root . handlers logging . root = root logging . Logger . root = root # type: ignore logging . Logger . manager = logging . Manager ( root ) # type: ignore # https://github.com/kivy/kivy/issues/6733 logging . basicConfig ( ** kwargs ) get_prefix () Obtain the current global prefix to use when logging public (non-private) data. Source code in confidential_ml_utils\\logging.py def get_prefix () -> Optional [ str ]: \"\"\" Obtain the current global prefix to use when logging public (non-private) data. \"\"\" return _PREFIX set_prefix ( prefix ) Set the global prefix to use when logging public (non-private) data. This method is thread-safe. Source code in confidential_ml_utils\\logging.py def set_prefix ( prefix : str ) -> None : \"\"\" Set the global prefix to use when logging public (non-private) data. This method is thread-safe. \"\"\" with _LOCK : global _PREFIX _PREFIX = prefix","title":"logging"},{"location":"logging/#logging","text":"","title":"Logging"},{"location":"logging/#confidential_ml_utils.logging","text":"Utilities around logging data which may or may not contain private content.","title":"confidential_ml_utils.logging"},{"location":"logging/#confidential_ml_utils.logging.ConfidentialLogger","text":"Subclass of the default logging class with an explicit category parameter on all logging methods. It will pass an extra param with prefix key (value depending on whether category is public or private) to the handlers. The default value for data category is PRIVATE for all methods. Implementation is inspired by: https://github.com/python/cpython/blob/3.8/Lib/logging/ init .py","title":"ConfidentialLogger"},{"location":"logging/#confidential_ml_utils.logging.ConfidentialLogger.critical","text":"Log msg % args with severity CRITICAL . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.critical(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def critical ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `CRITICAL`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.critical(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( CRITICAL ): self . _log ( CRITICAL , msg , category , args , ** kwargs )","title":"critical()"},{"location":"logging/#confidential_ml_utils.logging.ConfidentialLogger.debug","text":"Log msg % args with severity DEBUG . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.debug(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def debug ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `DEBUG`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.debug(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( DEBUG ): self . _log ( DEBUG , msg , category , args , ** kwargs )","title":"debug()"},{"location":"logging/#confidential_ml_utils.logging.ConfidentialLogger.error","text":"Log msg % args with severity ERROR . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.error(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def error ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `ERROR`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.error(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( ERROR ): self . _log ( ERROR , msg , category , args , ** kwargs )","title":"error()"},{"location":"logging/#confidential_ml_utils.logging.ConfidentialLogger.info","text":"Log msg % args with severity INFO . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.info(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def info ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `INFO`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.info(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( INFO ): self . _log ( INFO , msg , category , args , ** kwargs )","title":"info()"},{"location":"logging/#confidential_ml_utils.logging.ConfidentialLogger.warning","text":"Log msg % args with severity WARNING . To log public (non-private) data, use the keyword argument category with a DataCategory.PUBLIC value, e.g. logger.warning(\"public data\", category=DataCategory.PUBLIC) Source code in confidential_ml_utils\\logging.py def warning ( self , msg : str , category : DataCategory = DataCategory . PRIVATE , * args , ** kwargs ): \"\"\" Log `msg % args` with severity `WARNING`. To log public (non-private) data, use the keyword argument `category` with a `DataCategory.PUBLIC` value, e.g. logger.warning(\"public data\", category=DataCategory.PUBLIC) \"\"\" if self . isEnabledFor ( WARNING ): self . _log ( WARNING , msg , category , args , ** kwargs )","title":"warning()"},{"location":"logging/#confidential_ml_utils.logging.enable_confidential_logging","text":"The default format is logging.BASIC_FORMAT ( %(levelname)s:%(name)s:%(message)s ). All other kwargs are passed to logging.basicConfig . Sets the default logger class and root logger to be confidential. This means the format string %(prefix) will work. Set the format using the format kwarg. If running in Python >= 3.8, will attempt to add force=True to the kwargs for logging.basicConfig. After calling this method, use the kwarg category to pass in a value of DataCategory to denote data category. The default is PRIVATE . That is, if no changes are made to an existing set of log statements, the log output should be the same. The standard implementation of the logging API is a good reference: https://github.com/python/cpython/blob/3.9/Lib/logging/ init .py Source code in confidential_ml_utils\\logging.py def enable_confidential_logging ( prefix : str = \"SystemLog:\" , ** kwargs ) -> None : \"\"\" The default format is `logging.BASIC_FORMAT` (`%(levelname)s:%(name)s:%(message)s`). All other kwargs are passed to `logging.basicConfig`. Sets the default logger class and root logger to be confidential. This means the format string `%(prefix)` will work. Set the format using the `format` kwarg. If running in Python >= 3.8, will attempt to add `force=True` to the kwargs for logging.basicConfig. After calling this method, use the kwarg `category` to pass in a value of `DataCategory` to denote data category. The default is `PRIVATE`. That is, if no changes are made to an existing set of log statements, the log output should be the same. The standard implementation of the logging API is a good reference: https://github.com/python/cpython/blob/3.9/Lib/logging/__init__.py \"\"\" set_prefix ( prefix ) if \"format\" not in kwargs : kwargs [ \"format\" ] = f \"%(prefix)s { logging . BASIC_FORMAT } \" # Ensure that all loggers created via `logging.getLogger` are instances of # the `ConfidentialLogger` class. logging . setLoggerClass ( ConfidentialLogger ) if len ( logging . root . handlers ) > 0 : p = get_prefix () for line in _logging_basic_config_set_warning . splitlines (): print ( f \" { p }{ line } \" , file = sys . stderr ) if \"force\" not in kwargs and sys . version_info >= ( 3 , 8 ): kwargs [ \"force\" ] = True old_root = logging . root root = ConfidentialLogger ( logging . root . name ) root . handlers = old_root . handlers logging . root = root logging . Logger . root = root # type: ignore logging . Logger . manager = logging . Manager ( root ) # type: ignore # https://github.com/kivy/kivy/issues/6733 logging . basicConfig ( ** kwargs )","title":"enable_confidential_logging()"},{"location":"logging/#confidential_ml_utils.logging.get_prefix","text":"Obtain the current global prefix to use when logging public (non-private) data. Source code in confidential_ml_utils\\logging.py def get_prefix () -> Optional [ str ]: \"\"\" Obtain the current global prefix to use when logging public (non-private) data. \"\"\" return _PREFIX","title":"get_prefix()"},{"location":"logging/#confidential_ml_utils.logging.set_prefix","text":"Set the global prefix to use when logging public (non-private) data. This method is thread-safe. Source code in confidential_ml_utils\\logging.py def set_prefix ( prefix : str ) -> None : \"\"\" Set the global prefix to use when logging public (non-private) data. This method is thread-safe. \"\"\" with _LOCK : global _PREFIX _PREFIX = prefix","title":"set_prefix()"}]}